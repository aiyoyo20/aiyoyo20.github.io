<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Python on AI YOYO</title>
    <link>/tags/python/</link>
    <description>Recent content in Python on AI YOYO</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Fri, 13 Jan 2023 23:04:36 +0800</lastBuildDate><atom:link href="/tags/python/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>generator</title>
      <link>/post/generator/</link>
      <pubDate>Fri, 13 Jan 2023 23:04:36 +0800</pubDate>
      
      <guid>/post/generator/</guid>
      <description>yield 关键字初识 先看一个简单例子： def yie(): n = 1 yield n print(n) n += 1 yield n print(n) n += 1 yield n print(n) a = yie() one = next(a) print(f&#39;one {one}&#39;) two = next(a) print(f&#39;two {two}&#39;) thr = next(a) print(f&#39;thr {thr}&#39;) # one 1 # 1 # two 2 # 2 # thr 3 当调用时，遇到 yield 关键字时函数和遇到 return 用类似的结果，返回一个值，但不同</description>
    </item>
    
    <item>
      <title>spider</title>
      <link>/post/spider/</link>
      <pubDate>Mon, 09 Jan 2023 20:17:50 +0800</pubDate>
      
      <guid>/post/spider/</guid>
      <description>第五章 爬虫 一、常用库与模块 1. 试列出至少三种目前流行的大型数据库的名称: ____、____、____, 其中您最熟悉的是 ____, 从 ____ 年开始使用（考察对数据可的熟悉程度，同时考察你的工作年限注意和自己简历一致）。</description>
    </item>
    
    <item>
      <title>python_</title>
      <link>/post/python_/</link>
      <pubDate>Mon, 09 Jan 2023 19:38:13 +0800</pubDate>
      
      <guid>/post/python_/</guid>
      <description>一、元类 1.Python 中类方法、类实例方法、静态方法有何区别？ 类方法：是类对象的方法，在定义时需要在上方使用 @classmethod 进行装饰，形参为 cls，表示类对象，类对象和实例对象都可调用； 类实例方法：是类实例化对象的方法，只有实</description>
    </item>
    
    <item>
      <title>python_base</title>
      <link>/post/python_base/</link>
      <pubDate>Mon, 09 Jan 2023 18:44:22 +0800</pubDate>
      
      <guid>/post/python_base/</guid>
      <description>一、基础语法 1. 输入与输出 1.1 代码中要修改不可变数据会出现什么问题？抛出什么异常？ 代码不会正常运行，抛出 TypeError 异常。 1.2 a=1,b=2, 不用中间变量交换 a 和 b 的值？ 方法一： a = a + b b = a - b a = a - b 方法二： a = a ^ b b =</description>
    </item>
    
    <item>
      <title>model_itertools</title>
      <link>/post/model_itertools/</link>
      <pubDate>Fri, 18 Nov 2022 23:39:24 +0800</pubDate>
      
      <guid>/post/model_itertools/</guid>
      <description>itertools 标准化了一个快速、高效利用内存的核心工具集，这些工具本身或组合都很有用。它们一起形成了“迭代器代数”，这使得在纯 Python 中有可能创建简洁又高效的专用工具。 无穷迭代器： count() itertools.count(start=0, step=1) 可以设置两个参数，第一个参数为起</description>
    </item>
    
    <item>
      <title>built-in-functions</title>
      <link>/post/built-in-functions/</link>
      <pubDate>Tue, 25 Oct 2022 16:48:59 +0800</pubDate>
      
      <guid>/post/built-in-functions/</guid>
      <description>map() map()函数语法： map(function,iterable,&amp;hellip;) 参数: function&amp;ndash;函数 iterable&amp;ndash;一个或多个序列 返回值 Python2.x返回列表。 Python3.x返回迭代器对象。 传很多个iterable</description>
    </item>
    
    <item>
      <title>CP_1_阻塞非阻塞、异步同步、并行并发</title>
      <link>/post/cp_1_%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BC%82%E6%AD%A5%E5%90%8C%E6%AD%A5%E5%B9%B6%E8%A1%8C%E5%B9%B6%E5%8F%91/</link>
      <pubDate>Tue, 25 Oct 2022 16:48:59 +0800</pubDate>
      
      <guid>/post/cp_1_%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BC%82%E6%AD%A5%E5%90%8C%E6%AD%A5%E5%B9%B6%E8%A1%8C%E5%B9%B6%E5%8F%91/</guid>
      <description>1. 阻塞，非阻塞 首先，阻塞这个词来自操作系统的线程/进程的状态模型中，如下图： 进程状态： 一个线程/进程经历的5个状态，创建，就绪，运行，阻塞，终止。各个状态的转换条件如上图，其中有个阻塞状态，就是说当线</description>
    </item>
    
    <item>
      <title>CP_2_进程</title>
      <link>/post/cp_2_%E8%BF%9B%E7%A8%8B/</link>
      <pubDate>Tue, 25 Oct 2022 16:48:59 +0800</pubDate>
      
      <guid>/post/cp_2_%E8%BF%9B%E7%A8%8B/</guid>
      <description>概念 进程就是操作系统中执行的一个程序，操作系统以进程为单位分配存储空间，每个进程都有自己的地址空间、数据栈以及其他用于跟踪进程执行的辅助数据，操作系统管理所有进程的执行，为它们合理的分配资源。进程可以</description>
    </item>
    
    <item>
      <title>CP_3_线程</title>
      <link>/post/cp_3_%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>Tue, 25 Oct 2022 16:48:59 +0800</pubDate>
      
      <guid>/post/cp_3_%E7%BA%BF%E7%A8%8B/</guid>
      <description>概念 一个进程还可以拥有多个并发的执行线索，简单的说就是拥有多个可以获得CPU调度的执行单元，这就是所谓的线程。由于线程在同一个进程下，它们可以共享相同的上下文，因此相对于进程而言，线程间的信息共享和通</description>
    </item>
    
    <item>
      <title>CP_4_协程</title>
      <link>/post/cp_4_%E5%8D%8F%E7%A8%8B/</link>
      <pubDate>Tue, 25 Oct 2022 16:48:59 +0800</pubDate>
      
      <guid>/post/cp_4_%E5%8D%8F%E7%A8%8B/</guid>
      <description></description>
    </item>
    
    <item>
      <title>datatype-datail-and-deep-shallow-copy</title>
      <link>/post/datatype-datail-and-deep-shallow-copy/</link>
      <pubDate>Tue, 25 Oct 2022 16:48:59 +0800</pubDate>
      
      <guid>/post/datatype-datail-and-deep-shallow-copy/</guid>
      <description>Int(整型) 标准的 Python 实现是用 C 语言编写的。这意味着每一个 Python 对象都是一个伪 C 语言结构体，该结构体不仅包含其值，还有其他信息。例如，当我们在 Python 中定义一个整型，例如 x = 10000 时，x 并不是一个“原生”整型，而是</description>
    </item>
    
    <item>
      <title>decorator</title>
      <link>/post/decorator/</link>
      <pubDate>Tue, 25 Oct 2022 16:48:59 +0800</pubDate>
      
      <guid>/post/decorator/</guid>
      <description>闭包 1、闭包的定义：在一些语言中，在函数中可以（嵌套）定义另一个函数时，如果内部的函数引用了外部的函数的变量，则可能产生闭包。闭包可以用来在一个函数与一组“私有”变量之间创建关联关系。在给定函数被多次</description>
    </item>
    
    <item>
      <title>descriptors</title>
      <link>/post/descriptors/</link>
      <pubDate>Tue, 25 Oct 2022 16:48:59 +0800</pubDate>
      
      <guid>/post/descriptors/</guid>
      <description>:</description>
    </item>
    
    <item>
      <title>design-patterns_singleton</title>
      <link>/post/design-patterns_singleton/</link>
      <pubDate>Tue, 25 Oct 2022 16:48:59 +0800</pubDate>
      
      <guid>/post/design-patterns_singleton/</guid>
      <description>装饰器实现 函数装饰器实现单例模式 def singleton(cls): __instance = {} # 创建一个字典用来保存被装饰类的实例对象 _instance = {} def _singleton(*args, **kwargs): # 判断这个类有没有创建过对象，没有新创建一个，有则返回之前创建的 if not cls in _instance: _instance[cls] = cls(*args, **kwargs) return _instance[cls] return _singleton @singleton class A(object): def __init__(self, a=0): self.a =</description>
    </item>
    
    <item>
      <title>development_envirnment</title>
      <link>/post/development_envirnment/</link>
      <pubDate>Tue, 25 Oct 2022 16:48:59 +0800</pubDate>
      
      <guid>/post/development_envirnment/</guid>
      <description>operating environment 系统：manjaro-xfce-20.2 IDE：Pycharm 个人看法： 系统的话当然是Mac最好了，但是价格摆在那。 没有的话在 Linux 和 Win更推崇使用 Linux，能够对电脑有一个更好的了解，熟悉命令之</description>
    </item>
    
    <item>
      <title>errors-and-exceptions</title>
      <link>/post/errors-and-exceptions/</link>
      <pubDate>Tue, 25 Oct 2022 16:48:59 +0800</pubDate>
      
      <guid>/post/errors-and-exceptions/</guid>
      <description>语法错误 基本由编程不规范造成的，如括号、引号的不匹配，缩进的不正确，二值比较符号写成赋值，冒号的缺少等等造成语句的编译异常。 异常 在语法完全正确的情况下，程序也可能出现不能正常运行的情况。这种情况称之为</description>
    </item>
    
    <item>
      <title>flask</title>
      <link>/post/flask/</link>
      <pubDate>Tue, 25 Oct 2022 16:48:59 +0800</pubDate>
      
      <guid>/post/flask/</guid>
      <description>Flask框架的优点 Flask框架是一个短小精悍、可扩展性强的web框架。html Flask框架依赖组件 Flask依赖于werkzurg组件，实现wsgi使用的就是werkzurg。web Flask蓝</description>
    </item>
    
    <item>
      <title>flask</title>
      <link>/post/flask/</link>
      <pubDate>Tue, 25 Oct 2022 16:48:59 +0800</pubDate>
      
      <guid>/post/flask/</guid>
      <description>路由 简单路由 @app.route(&#39;/hello/&#39;) def hello(): return &#39;Hello&#39; 带参数的路由 （1） @app.route(&#39;/hello/&amp;lt;name&amp;gt;&#39;) def hello(name): return &#39;Hello %s&#39; % name （2） ?key=value形式传参 上面我们接受参数使用的是path形式，下面我们来使用查询字符串的形式，即?key=value 如果有多个参数，则</description>
    </item>
    
    <item>
      <title>iterator</title>
      <link>/post/iterator/</link>
      <pubDate>Tue, 25 Oct 2022 16:48:59 +0800</pubDate>
      
      <guid>/post/iterator/</guid>
      <description>魔法方法介绍 object.iter(self) 此方法在需要为容器创建迭代器时被调用。此方法应该返回一个新的迭代器对象，它能够逐个迭代容器中的所有对象。对于映射，它应该逐个迭代容器中的键。 迭代器对象也需要实现此方法；它们需要返回对象自</description>
    </item>
    
    <item>
      <title>magic_mothods</title>
      <link>/post/magic_mothods/</link>
      <pubDate>Tue, 25 Oct 2022 16:48:59 +0800</pubDate>
      
      <guid>/post/magic_mothods/</guid>
      <description>11.1. 简介 本指南归纳于我的几个月的博客，主题是 魔法方法 。 什么是魔法方法呢？它们在面向对象的Python的处处皆是。它们是一些可以让你对类添加“魔法”的特殊方法。 它们经常是两个下划线包围来命名的（比如 init ， lt</description>
    </item>
    
    <item>
      <title>model_functools</title>
      <link>/post/model_functools/</link>
      <pubDate>Tue, 25 Oct 2022 16:48:59 +0800</pubDate>
      
      <guid>/post/model_functools/</guid>
      <description></description>
    </item>
    
    <item>
      <title>model_lxml</title>
      <link>/post/model_lxml/</link>
      <pubDate>Tue, 25 Oct 2022 16:48:59 +0800</pubDate>
      
      <guid>/post/model_lxml/</guid>
      <description>基本使用 1、读取文本解析节点 from lxml import etree text=&#39;&#39;&#39; &amp;lt;div&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li class=&amp;quot;item-0&amp;quot;&amp;gt;&amp;lt;a href=&amp;quot;link1.html&amp;quot;&amp;gt;第一个&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li class=&amp;quot;item-1&amp;quot;&amp;gt;&amp;lt;a href=&amp;quot;link2.html&amp;quot;&amp;gt;second item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li class=&amp;quot;item-0&amp;quot;&amp;gt;&amp;lt;a href=&amp;quot;link5</description>
    </item>
    
    <item>
      <title>model_pillow</title>
      <link>/post/model_pillow/</link>
      <pubDate>Tue, 25 Oct 2022 16:48:59 +0800</pubDate>
      
      <guid>/post/model_pillow/</guid>
      <description>Pillow 调整大小 按宽度缩放 这是一个使用 Pillow 模块来调整图片大小的基本脚本： from PIL import Image basewidth = 300 img = Image.open(&#39;fullsized_image.jpg&#39;) wpercent = (basewidth / float(img.size[0])) hsize = int((float(img.size[1]) * float(wpercent))) img = img.resize((basewidth, hsize), Image.ANTIALIAS) img.save(&#39;resized_image.jpg&#39;) 这几行 Python 代码使用 Pillow 将一张图片 （fullsized_image.jpg） 调整为 300 像素的</description>
    </item>
    
    <item>
      <title>model_scrapy</title>
      <link>/post/model_scrapy/</link>
      <pubDate>Tue, 25 Oct 2022 16:48:59 +0800</pubDate>
      
      <guid>/post/model_scrapy/</guid>
      <description>scrapy 简介 下图显示了Scrapy架构及其组件的概述，以及系统内部发生的数据流的概要（以红色箭头显示）。下面提供了这些组件的简要说明以及有关它们的详细信息的链接。数据流也描述如下。 Scrapy中的数据流由执</description>
    </item>
    
    <item>
      <title>model_selenium</title>
      <link>/post/model_selenium/</link>
      <pubDate>Tue, 25 Oct 2022 16:48:59 +0800</pubDate>
      
      <guid>/post/model_selenium/</guid>
      <description>支持多种类型浏览器，以chrome为例 基本使用 from selenium import webdriver driver = webdriver.Chrome() driver.get(&#39;http://www.baidu.com&#39;) print(driver.page_source) driver.close() # 关闭当前窗口 driver.quit() # 关闭浏览器 查找元素 # 单个元素,有多个结果会取第一个 from selenium import webdriver browser = webdriver.Chrome() browser.get(&#39;https://www.taobao.com&#39;) input_first = browser.find_element_by_id(&#39;q&#39;) input_second = browser.find_element_by_css_selector(&#39;#q&#39;) input_third = browser.find_element_by_xpath(&#39;//*[@id=&amp;quot;q&amp;quot;]&#39;) print(input_first,input_second,input_third) browser.close() # 常用的查找方法 find_element_by_name find_element_by_xpath find_element_by_link_text find_element_by_partial_link_text find_element_by_tag_name find_element_by_class_name</description>
    </item>
    
    <item>
      <title>MY</title>
      <link>/post/my/</link>
      <pubDate>Tue, 25 Oct 2022 16:48:59 +0800</pubDate>
      
      <guid>/post/my/</guid>
      <description>python lambda 递归 阶乘 f = lambda n: f(n-1) * n if n&amp;gt;=2 else 1 序列乘积 a=[2,3,4] f = lambda n: f(n-1) * a[n] if n&amp;gt;=0 else 1 print(f(len(a))) 求和 f = lambda n: f(n-1) * n if n&amp;gt;=2 else 0 斐波那契数列 lambdafunc = lambda n : 1 if n == 1 or n == 2 else lambdafunc(n -1 ) + lambdafunc(n - 2)</description>
    </item>
    
    <item>
      <title>questions</title>
      <link>/post/questions/</link>
      <pubDate>Tue, 25 Oct 2022 16:48:59 +0800</pubDate>
      
      <guid>/post/questions/</guid>
      <description>#!/usr/bin/env python3 Author: aiyoyo🍉 1、可变类型陷阱 l = [] a = [] for i in range(10): a.append(i) l.append(a) print(l) l = [] a = {&#39;num&#39;: 0} for i in range(10): a[&#39;num&#39;] = i l.append(a) print(l) print(a) 都是类似的，每次新增的都是同一个对象，并在其后进行了修改，导致之前的也被修改（覆盖）。 2、lambda 陷</description>
    </item>
    
    <item>
      <title>queues-stacks</title>
      <link>/post/queues-stacks/</link>
      <pubDate>Tue, 25 Oct 2022 16:48:59 +0800</pubDate>
      
      <guid>/post/queues-stacks/</guid>
      <description>Python中栈、队列和优先级队列的实现 栈(Stack) 栈是一种LIFO(后进先出)的数据结构，有入栈(push)、出栈(pop)两种操作，且只能操作栈顶元素。 1、list list是Python内置的</description>
    </item>
    
    <item>
      <title>recurrence</title>
      <link>/post/recurrence/</link>
      <pubDate>Tue, 25 Oct 2022 16:48:59 +0800</pubDate>
      
      <guid>/post/recurrence/</guid>
      <description>递归 def normal_recursion(n): if n == 1: return 1 else: return n + normal_recursion(n-1) normal_recursion(5) 5 + normal_recursion(4) 5 + 4 + normal_recursion(3) 5 + 4 + 3 + normal_recursion(2) 5 + 4 + 3 + 2 + normal_recursion(1) 5 + 4 + 3 + 3 5 + 4 + 6 5 + 10 15 线性递归，每深入一层，就会产生新的局部变量，必须创建新的调用栈, 随着递归深度的增加, 创建</description>
    </item>
    
    <item>
      <title>spider-introduce</title>
      <link>/post/spider-introduce/</link>
      <pubDate>Tue, 25 Oct 2022 16:48:59 +0800</pubDate>
      
      <guid>/post/spider-introduce/</guid>
      <description>网络数据采集是指通过网络爬虫或网站公开 API 等方式从网站上获取数据信息。该方法可以将非结构化数据从网页中抽取出来，将其存储为统一的本地数据文件，并以结构化的方式存储。它支持图片、音频、视频等文件或附件的采</description>
    </item>
    
    <item>
      <title>test</title>
      <link>/post/test/</link>
      <pubDate>Tue, 25 Oct 2022 16:48:59 +0800</pubDate>
      
      <guid>/post/test/</guid>
      <description>第七章 测试 1. 禅道和 qc 的区别？ 都是缺陷管理工具。 A.QC 作为缺陷管理工具，QC 在缺陷管理方面，做的 相对完善。 提 bug 页面：填写内容可以根据测试需求，不断修改添加新的字段；以我上一家公司为例，在提 bug 过程中，有一下几</description>
    </item>
    
    <item>
      <title>web_framework</title>
      <link>/post/web_framework/</link>
      <pubDate>Tue, 25 Oct 2022 16:48:59 +0800</pubDate>
      
      <guid>/post/web_framework/</guid>
      <description>第四章 WEB 框架 一、Flask 1. Flask 中正则 URL 的实现？ @app.route(&amp;lt;URL&amp;gt;) 中 URL 显式支持 string、int、float、path 4 种类型，隐式支持正则。 第一步：写正则类，继承 BaseConverter，将匹配到的值设置为 regex 的值</description>
    </item>
    
  </channel>
</rss>
