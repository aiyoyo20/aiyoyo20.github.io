<!DOCTYPE html>
<html lang="en">

<head>
    
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
<meta name="HandheldFriendly" content="True" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
<meta name="generator" content="Hugo 0.93.3" />



<link rel="apple-touch-icon" sizes="180x180" href="https://cdn.jsdelivr.net/gh/amzrk2/cdn-stcapi@1/favicons/apple-touch-icon.png" />
<link rel="icon" type="image/png" sizes="32x32" href="https://cdn.jsdelivr.net/gh/amzrk2/cdn-stcapi@1/favicons/favicon-32x32.png" />
<link rel="icon" type="image/png" sizes="16x16" href="https://cdn.jsdelivr.net/gh/amzrk2/cdn-stcapi@1/favicons/favicon-16x16.png" />
<link rel="manifest" href="https://cdn.jsdelivr.net/gh/amzrk2/cdn-stcapi@1/favicons/site.webmanifest" />
<link rel="mask-icon" href="https://cdn.jsdelivr.net/gh/amzrk2/cdn-stcapi@1/favicons/safari-pinned-tab.svg" color="#8aa2d3" />
<link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/amzrk2/cdn-stcapi@1/favicons/favicon.ico" />
<meta name="theme-color" content="#ffffff" />


<title>redis - AI YOYO</title>


<meta name="author" content="会讲笑话的咸鱼王" />


<meta name="description" content="A minimal Hugo theme with nice theme color." />


<meta name="keywords" content="InterviewQuestions, Redis" />


<meta property="og:title" content="redis" />
<meta name="twitter:title" content="redis" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/redis/" /><meta property="og:description" content="redis 是什么？ redis 是 nosql(也是个巨大的 map) 单线程，但是可处理 1 秒 10w 的并发（数据都在内存中） Redis 的全称是：Remote Dictionary.Server，本质上是一个 Key-Value 类型的内存数据库，很像memcache" />
<meta name="twitter:description" content="redis 是什么？ redis 是 nosql(也是个巨大的 map) 单线程，但是可处理 1 秒 10w 的并发（数据都在内存中） Redis 的全称是：Remote Dictionary.Server，本质上是一个 Key-Value 类型的内存数据库，很像memcache" /><meta property="og:image" content="/img/og.png" />
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="/img/og.png" /><meta property="article:published_time" content="2023-01-09T17:40:42+08:00" /><meta property="article:modified_time" content="2023-01-09T17:40:42+08:00" />


<style>
    @media (prefers-color-scheme: dark) {
        body[data-theme='auto'] img {
            filter: brightness(60%);
        }
    }

    body[data-theme='dark'] img {
        filter: brightness(60%);
    }
</style>




<link rel="stylesheet" href="/assets/css/fuji.min.b4a21b5d3eb1d0a51297e31230a65fc25e387843e45ec3a2d9176cd8d163c216d99b9b13a618b28f537c3b559ec8a408183b0fbfad48daddb9befa7d3ef90eed.css" integrity="sha512-tKIbXT6x0KUSl&#43;MSMKZfwl44eEPkXsOi2Rds2NFjwhbZm5sTphiyj1N8O1WeyKQIGDsPv61I2t25vvp9PvkO7Q==" />








</head>

<body
  data-theme="auto"
  data-theme-auto='true'
  >
    <script data-cfasync="false">
  
  var fujiThemeData = localStorage.getItem('fuji_data-theme');
  
  if (!fujiThemeData) {
    localStorage.setItem('fuji_data-theme', 'auto');
  } else {
    
    if (fujiThemeData !== 'auto') {
      document.body.setAttribute('data-theme', fujiThemeData === 'dark' ? 'dark' : 'light');
    }
  }
</script>

    <header>
    <div class="container-lg clearfix">
        <div class="col-12 header">
            <a class="title-main" href="/">AI YOYO</a>
            
            <span class="title-sub">个人日常学习、生活分享</span>
            
        </div>
    </div>
</header>

    <main>
        <div class="container-lg clearfix">
            
            <div class="col-12 col-md-9 float-left content">
                
<article>
    
    <h2 class="post-item post-title">
        <a href="/post/redis/">redis</a>
    </h2>
    <div class="post-item post-meta">
        <span><i class="iconfont icon-today-sharp"></i>&nbsp;2023-01-09</span>

<span><i class="iconfont icon-file-tray-sharp"></i>&nbsp;19316 words</span>

<span><i class="iconfont icon-pricetags-sharp"></i>&nbsp;<a href="/tags/interviewquestions">InterviewQuestions</a>&nbsp;<a href="/tags/redis">Redis</a>&nbsp;</span>

    </div>
    
    <div class="post-content markdown-body">
        <h4 id="redis-是什么">redis 是什么？</h4>
<p>redis 是 nosql(也是个巨大的 map) 单线程，但是可处理 1 秒 10w 的并发（数据都在内存中）</p>
<p>Redis 的全称是：Remote Dictionary.Server，本质上是一个 Key-Value 类型的内存数据库，很像memcached，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据 flush 到硬盘上进行保存。</p>
<p>因为是纯内存操作，Redis 的性能非常出色，每秒可以处理超过 10 万次读写操作，是已知性能最快的 Key-Value DB。</p>
<p>Redis 的出色之处不仅仅是性能，Redis 最大的魅力是支持保存多种数据结构，此外单个 value 的最大限制是 1GB，不像 memcached 只能保存 1MB 的数据，因此 Redis 可以用来实现很多有用的功能。</p>
<p>比方说用他的 List 来做 FIFO 双向链表，实现一个轻量级的高性 能消息队列服务，用他的 Set 可以做高性能的 tag 系统等等。</p>
<p>另外 Redis 也可以对存入的 Key-Value 设置 expire 时间，因此也可以被当作一 个功能加强版的 memcached 来用。 Redis 的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此 Redis 适合的场景主要局限在较小数据量的高性能操作和运算上。</p>
<h4 id="redis-主要消耗什么物理资源">Redis 主要消耗什么物理资源？</h4>
<p>内存。</p>
<h4 id="redis-有多少个库">Redis 有多少个库？</h4>
<p>Redis 一个实例下有 16 个。</p>
<h4 id="redis-默认端口默认过期时间value-最多可以容纳的数据长度">Redis 默认端口，默认过期时间，Value 最多可以容纳的数据长度？</h4>
<pre><code>1. 默认端口：`6379`
2. 默认过期时间：可以说永不过期，一般情况下，当配置中开启了超出最大内存限制就写磁盘的话， 那么没有设置过期时间的 key 可能会被写到磁盘上。假如没设置，那么 REDIS 将使用 LRU 机制，将内存中的老数据删除，并写入新数据。
3.Value 最多可以容纳的数据长度是：512M。
</code></pre>
<h4 id="redis-中-list-底层实现有哪几种有什么区别">Redis 中 list 底层实现有哪几种？有什么区别？</h4>
<pre><code>列表对象的编码可以是 `ziplist` 或者 `linkedlist`
ziplist 是一种 `压缩链表`，它的好处是更能 `节省内存空间`，因为它所存储的内容都是在连续的内存区域当中的。
</code></pre>
<blockquote>
<p>当列表对象元素不大，每个元素也不大的时候，就采用 ziplist 存储。但当数据量过大时就 ziplist 就不是那么好用了。因为为了保证他存储内容在内存中的连续性，插入的复杂度是 O (N)，即每次插入都会重新进行 realloc。</p>
</blockquote>
<h4 id="redis-数据类型及对应使用场所">redis 数据类型及对应使用场所。</h4>
<ul>
<li><code>String</code>
<ol>
<li>String 是 Redis 最为常用的一种数据类型，String 的数据结构为 key/value 类型，可以用来做微博涨粉，点赞关注数变化。</li>
<li>存储 json 类型对象,2 计数器,3 优酷视频点赞等</li>
<li>常用命令: set,get,decr,incr,mget 等。</li>
</ol>
</li>
<li><code>Hash</code>
<ol>
<li>Hash 类型可以看成是一个 key/value 都是 String 的 Map 容器。 通常用来存储对象数据类型</li>
<li>常用命令：hget,hset,hgetall 等。</li>
</ol>
</li>
<li><code>List</code>
<ol>
<li>List 用于存储一个有序的字符串列表，常用的操作是向队列两 端添加元素或者获得列表的某一片段。可用来做微信朋友圈按时间顺序加载</li>
<li>可以使用 redis 的 list 模拟队列,堆,栈</li>
<li>常用命令：lpush,rpush,lpop,rpop,lrange 等</li>
</ol>
</li>
<li><code>Set</code>
<ol>
<li>Set 可以理解为一组无序的字符集合，Set 中相同的元素是不会重复出现的，相同的元素只保留一个。可用来做共同好友，共同关注等</li>
<li>常用命令：sadd,spop,smembers,sunion 等。</li>
</ol>
</li>
<li><code>Sorted Set（有序集合）</code>
<ol>
<li>有序集合是在集合的基础上为每一个元素关联一个分数，Redis 通过分数为集合中的成员进行排序。可用来做各类排行榜应用</li>
<li>常用命令：zadd,zrange,zrem,zcard 等。</li>
</ol>
</li>
</ul>
<h5 id="应用场景">应用场景:</h5>
<pre><code>1. 取最新 N 个数据的操作
2. 排行榜应用，取 TOP N 操作
3. 需要精准设定过期时间的应用
4. 计数器应用
5. uniq 操作，获取某段时间所有数据排重值
6. Pub/Sub 构建实时消息系统
7. 构建队列系统
8. 缓存
</code></pre>
<h5 id="redis-有哪些适合的场景">Redis 有哪些适合的场景？</h5>
<pre><code>（1）会话缓存（Session Cache）
    最常用的一种使用 Redis 的情景是会话缓存（sessioncache），用 Redis 缓存会话比其他存储（如 Memcached）的优势在于：Redis 提供持久化。当维护一个不是严格要求一致性的缓存时，如果用户的购物车信息全部丢失，大部分人都会不高兴的，现在，他们还会这样吗？

    幸运的是，随着 Redis 这些年的改进，很容易找到怎么恰当的使用 Redis 来缓存会话的文档。甚至广为人知的商业平台 Magento 也提供 Redis 的插件。

（2）全页缓存（FPC）
    除基本的会话 token 之外，Redis 还提供很简便的 FPC 平台。回到一致性问题，即使重启了 Redis 实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进，类似 PHP 本地 FPC。        再次以 Magento 为例，Magento 提供一个插件来使用 Redis 作为全页缓存后端。此外，对 WordPress 的用户来说，Pantheon 有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。

（3）队列
    Reids 在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得 Redis 能作为一个很好的消息队列平台来使用。Redis 作为队列使用的操作，就类似于本地程序语言（如 Python）对 list 的 push/pop 操作。
    如果你快速的在 Google 中搜索“Redis queues”，你马上就能找到大量的开源项目，这些项目的目的就是利用 Redis 创建非常好的后端工具，以满足各种队列需求。例如，Celery 有一个后台就是使用 Redis 作为 broker，你可以从这里去查看。

（4）排行榜/计数器
    Redis 在内存中对数字进行递增或递减的操作实现的非常好。
    集合（Set）和有序集合（SortedSet）也使得我们在执行这些操作的时候变的非常简单，Redis 只是正好提供了这两种数据结构。
    所以，我们要从排序集合中获取到排名最靠前的 10 个用户–我们称之为“user_scores”，我们只需要像下面一样执行即可：
    当然，这是假定你是根据你用户的分数做递增的排序。
    如果你想返回用户及用户的分数，你需要这样执行：`ZRANGE user_scores 0 10 WITHSCORES`

    Agora Games 就是一个很好的例子，用 Ruby 实现的，它的排行榜就是使用 Redis 来存储数据的，你可以在这里看到。

（5）发布/订阅
    最后（但肯定不是最不重要的）是 Redis 的发布/订阅功能。发布/订阅的使用场景确实非常多。我已看见人们在社交网络连接中使用，还可作为基于发布/订阅的脚本触发器，甚至用 Redis 的发布/订阅功能来建立聊天系统！
</code></pre>
<h4 id="redis-有哪几种数据淘汰策略">Redis 有哪几种数据淘汰策略？</h4>
<p>Redis 的内存淘汰策略是指在 Redis 的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据。</p>
<pre><code>noeviction：     当内存不足以容纳新写入数据时，新写入操作会报错。(禁止驱逐数据)
allkeys-lru：    当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key。
allkeys-random： 当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。
volatile-lru：   当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 key。
volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 key。
volatile-ttl：   当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 key 优先移除()优先回收存活时间（TTL）较短的键)。
</code></pre>
<h4 id="说说-redis-哈希槽的概念">说说 Redis 哈希槽的概念？</h4>
<p>Redis 集群没有使用一致性 hash,而是引入了哈希槽的概念，Redis 集群有 16384 个哈希槽，每个 key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽，集群的每个节点负责一部分 hash 槽。</p>
<h4 id="怎么测试-redis-的连通性">怎么测试 Redis 的连通性？</h4>
<p>ping</p>
<h4 id="查看-redis-使用情况及状态信息用什么命令">查看 Redis 使用情况及状态信息用什么命令？</h4>
<p>info</p>
<h4 id="redis-key-的过期时间和永久有效分别怎么设置">Redis key 的过期时间和永久有效分别怎么设置？</h4>
<p>EXPIRE 和 PERSIST 命令</p>
<h4 id="redis-如何做大量数据插入">Redis 如何做大量数据插入？</h4>
<p>Redis2.6 开始 Redis-cli 支持一种新的被称之为管道(pipe mode)的新模式用于执行大量数据插入工作。</p>
<h4 id="redis-中的管道有什么用">Redis 中的管道有什么用？</h4>
<p>一次请求/响应服务器能实现处理新的请求即使旧的请求还未被响应，这样就可以将多个命令发送到服务器，而不用等待回复，最后在一个步骤中读取该答复。</p>
<p>这就是管道（pipelining），是一种几十年来广泛使用的技术。例如许多 POP3 协议已经实现支持这个功能，大大加快了从服务器下载新邮件的过程。</p>
<h4 id="redis-与其他-key-value-存储有什么不同">Redis 与其他 key-value 存储有什么不同？</h4>
<p>Redis 有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis 的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。</p>
<p>Redis 运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，应为数据量不能大于硬件内存。在内存数据库方面的另一个优点是，相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样 Redis 可以做很多内部复杂性很强的事情。 同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。</p>
<h4 id="4为什么-redis-是单线程的都那么快">4.为什么 redis 是单线程的都那么快？</h4>
<pre><code>1.数据存于内存
2.用了多路复用 I/O
3.单线程
</code></pre>
<h4 id="分布式-redis-是前期做还是后期规模上来了再做好为什么">分布式 Redis 是前期做还是后期规模上来了再做好？为什么？</h4>
<p>既然 Redis 是如此的轻量（单实例只使用 1M 内存）,为防止以后的扩容，最好的办法就是一开始就启动较多实例。即便你只有一台服务器，你也可以一开始就让Redis 以分布式的方式运行，使用分区，在同一台服务器上启动多个实例。</p>
<p>一开始就多设置几个 Redis 实例，例如 32 或者 64 个实例，对大多数用户来说这操作起来可能比较麻烦，但是从长久来看做这点牺牲是值得的。</p>
<p>这样的话，当你的数据不断增长，需要更多的 Redis 服务器时，你需要做的就是仅仅将Redis实例从一台服务迁移到另外一台服务器而已（而不用考虑重新分区的问题）。一旦你添加了另一台服务器，你需要将你一半的 Redis 实例从第一台机器迁移到第二台机器。</p>
<h4 id="twemproxy-是什么">Twemproxy 是什么？</h4>
<p>Twemproxy 是 Twitter 维护的（缓存）代理系统，代理 Memcached 的ASCII 协议和 Redis 协议。它是单线程程序，使用 c 语言编写，运行起来非常快。它是采用 Apache 2.0 license 的开源软件。</p>
<p>Twemproxy 支持自动分区，如果其代理的其中一个 Redis 节点不可用时，会自动将该节点排除（这将改变原来的 keys-instances 的映射关系，所以你应该仅在把 Redis 当缓存时使用 Twemproxy)。</p>
<p>Twemproxy 本身不存在单点问题，因为你可以启动多个 Twemproxy 实例，然后让你的客户端去连接任意一个 Twemproxy 实例。</p>
<p>Twemproxy 是 Redis 客户端和服务器端的一个中间层，由它来处理分区功能应该不算复杂，并且应该算比较可靠的。</p>
<h4 id="支持一致性哈希的客户端有哪些">支持一致性哈希的客户端有哪些？</h4>
<p>Redis-rb、PRedis 等。</p>
<h4 id="redis-的内存占用情况怎么样">Redis 的内存占用情况怎么样？</h4>
<p>给你举个例子： 100 万个键值对（键是 0 到 999999 值是字符串“hello world”）在我的32 位的 Mac 笔记本上 用了 100MB。同样的数据放到一个 key 里只需要16MB，这是因为键值有一个很大的开销。 在 Memcached 上执行也是类似的结果，但是相对Redis的开销要小一点点，因为 Redis 会记录类型信息引用计数等等。</p>
<p>当然，大键值对时两者的比例要好很多。</p>
<p>64 位的系统比 32 位的需要更多的内存开销，尤其是键值对都较小时，这是因为64 位的系统里指针占用了 8 个字节。 但是，当然，64 位系统支持更大的内存，所以为了运行大型的 Redis 服务器或多或少的需要使用 64 位的系统。</p>
<h4 id="redis-的内存用完了会发生什么">Redis 的内存用完了会发生什么？</h4>
<p>如果达到设置的上限，Redis 的写命令会返回错误信息（但是读命令还可以正常返回）</p>
<p>或者你可以将 Redis 当缓存来使用配置淘汰机制，当 Redis 达到内存上限时会冲刷掉旧的内容。</p>
<h4 id="redis-是单线程的如何提高多核cpu的利用率">Redis 是单线程的，如何提高多核CPU的利用率？</h4>
<p>可以在同一个服务器部署多个 Redis 的实例，并把他们当作不同的服务器来使用，在某些时候，无论如何一个服务器是不够的，所以，如果你想使用多个 CPU，你可以考虑一下分片（shard）。</p>
<h4 id="一个-redis-实例最多能存放多少的keyslistsetsorted-set-他们最多能存放多少元素">一个 Redis 实例最多能存放多少的keys？List、Set、Sorted Set 他们最多能存放多少元素？</h4>
<p>理论上 Redis 可以处理多达 232 的 keys，并且在实际中进行了测试，每个实例至少存放了2亿 5 千万的 keys。我们正在测试一些较大的值。</p>
<p>任何 list、set、和 sorted set 都可以放 232 个元素。</p>
<p>换句话说，Redis 的存储极限是系统中的可用内存值。</p>
<h4 id="redis-官方为什么不提供-windows-版本">Redis 官方为什么不提供 Windows 版本？</h4>
<p>因为目前 Linux 版本已经相当稳定，而且用户量很大，无需开发 windows 版本，反而会带来兼容性等问题。</p>
<h4 id="一个字符串类型的值能存储最大容量是多少">一个字符串类型的值能存储最大容量是多少？</h4>
<p>512M</p>
<h4 id="为什么-redis-需要把所有数据放到内存中">为什么 Redis 需要把所有数据放到内存中？</h4>
<p>Redis 为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。</p>
<p>所以 redis 具有快速和数据持久化的特征，如果不将数据放在内存中，磁盘 I/O 速度为严重影响 redis的性能。</p>
<p>在内存越来越便宜的今天，redis 将会越来越受欢迎， 如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。</p>
<h4 id="redis-如何实现延时队列">Redis 如何实现延时队列</h4>
<p>使用 sortedset，使用时间戳做 score, 消息内容作为 key,调用 zadd 来生产消息，消费者使用 zrangbyscore 获取 n 秒之前的数据做轮询处理。</p>
<h4 id="使用-redis-有哪些好处">使用 Redis 有哪些好处？</h4>
<pre><code>(1) 速度快，因为数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是 O(1)
(2) 支持丰富数据类型，支持 string，list，set，sorted set，hash
(3) 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行
(4) 丰富的特性：可用于缓存，消息，按 key 设置过期时间，过期后将会自动删除
</code></pre>
<h4 id="redis-当中有哪些数据结构">Redis 当中有哪些数据结构</h4>
<pre><code>字符串 String、
字典 Hash、
列表 List、
集合 Set、
有序集合 SortedSet。
</code></pre>
<p>如果是高级用户，那么还会有，如果你是 Redis 中高级用户，还需要加上下面几种数据结构</p>
<pre><code>HyperLogLog、
Geo、
Pub/Sub。
</code></pre>
<h4 id="假如-redis-里面有-1-亿个-key其中有-10w-个-key-是以某个固定的已知的前缀开头的如果将它们全部找出来">假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？</h4>
<p>使用 keys 指令可以扫出指定模式的 key 列表。</p>
<h3 id="分区">分区</h3>
<h4 id="为什么要做-redis-分区">为什么要做 Redis 分区？</h4>
<p>分区可以让 Redis 管理更大的内存，Redis 将可以使用所有机器的内存。如果没有分区，你最多只能使用一台机器的内存。分区使 Redis 的计算能力通过简单地增加计算机得到成倍提升,Redis 的网络带宽也会随着计算机和网卡的增加而成倍增长。</p>
<h4 id="你知道有哪些-redis-分区实现方案">你知道有哪些 Redis 分区实现方案？</h4>
<p>客户端分区: 就是在客户端就已经决定数据会被存储到哪个 Redis 节点或者从哪个Redis节点读取。大多数客户端已经实现了客户端分区。</p>
<p>代理分区: 意味着客户端将请求发送给代理，然后代理决定去哪个节点写数据或者读数据。代理根据分区规则决定请求哪些 Redis 实例，然后根据 Redis 的响应结果返回给客户端。Redis 和 memcached 的一种代理实现就是 Twemproxy</p>
<p>查询路由(Query routing) : 意思是客户端随机地请求任意一个 Redis 实例，然后由 Redis 将请求转发给正确的 Redis 节点。Redis Cluster 实现了一种混合形式的查询路由，但并不是直接将请求从一个 Redis 节点转发到另一个 Redis 节点，而是在客户端的帮助下直接 redirected 到正确的 Redis 节点。</p>
<h4 id="redis-分区有什么缺点">Redis 分区有什么缺点？</h4>
<p>涉及多个 key 的操作通常不会被支持。例如你不能对两个集合求交集，因为他们可能被存储到不同的 Redis 实例（实际上这种情况也有办法，但是不能直接使用交集指令）。</p>
<p>同时操作多个 key,则不能使用 Redis 事务.</p>
<p>分区使用的粒度是key，不能使用一个非常长的排序key存储一个数据集（The partitioninggranularity is the key, so it is not possible to shard a dataset with a single hugekey like a very big sorted set）.</p>
<p>当使用分区的时候，数据处理会非常复杂，例如为了备份你必须从不同的Redis 实例和主机同时收集 RDB / AOF 文件。</p>
<p>分区时动态扩容或缩容可能非常复杂。Redis 集群在运行时增加或者删除Redis 节点，能做到最大程度对用户透明地数据再平衡，但其他一些客户端分区或者代理分区方法则不支持这种特性。然而，有一种预分片的技术也可以较好的解决这个问题。</p>
<p>如果 Redis 被当做一个持久化存储使用，必须使用固定的 keys-to-nodes 映射关系，节点的数量一旦确定不能变化。否则的话(即 Redis 节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有 Redis 集群可以做到这样。</p>
<h3 id="同步">同步</h3>
<h4 id="redis-的同步机制了解么">Redis 的同步机制了解么？</h4>
<p>从从同步。第一次同步时，主节点做一次 bgsave，并同时将后续修改操作记录到内存 buffer，待完成后将 rdb 文件全量同步到复制节点，复制节点接受完成后将 rdb 镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。</p>
<h4 id="缓存与数据库不一致怎么办">缓存与数据库不一致怎么办</h4>
<p>假设采用的主存分离，读写分离的数据库，如果一个线程 A 先删除缓存数据，然后将数据写入到主库当中，这个时候，主库和从库同步没有完成，线程 B 从缓存当中读取数据失败，从从库当中读取到旧数据，然后更新至缓存，这个时候，缓存当中的就是旧的数据。</p>
<p>发生上述不一致的原因在于，主从库数据不一致问题，加入了缓存之后，主从不一致的时间被拉长了</p>
<p>处理思路：
在从库有数据更新之后，将缓存当中的数据也同时进行更新，即当从库发生了数据更新之后，向缓存发出删除，淘汰这段时间写入的旧数据。</p>
<h4 id="主从数据库不一致如何解决">主从数据库不一致如何解决</h4>
<p>场景描述，对于主从库，读写分离，如果主从库更新同步有时差，就会导致主从库数据的不一致</p>
<pre><code>1、忽略这个数据不一致，在数据一致性要求不高的业务下，未必需要时时一致性
2、强制读主库，使用一个高可用的主库，数据库读写都在主库，添加一个缓存，提升数据读取的性能。
3、选择性读主库，添加一个缓存，用来记录必须读主库的数据，将哪个库，哪个表，哪个主键，作为缓存的 key,设置缓存失效的时间为主从库同步的时间，如果缓存当中有这个数据，直接读取主库，如果缓存当中没有这个主键，就到对应的从库中读取。
</code></pre>
<p>对方接着追问：如果这个 redis 正在给线上的业务提供服务，那使用 keys 指令会有什么问题？</p>
<p>这个时候你要回答 redis 关键的一个特性：</p>
<pre><code>redis 的单线程的。keys 指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用 scan 指令，scan 指令可以无阻塞的提取出指定模式的 key 列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用 keys 指令长。
</code></pre>
<h4 id="使用-redis-做过异步队列吗是如何实现的使用-list-类型保存数据信息">使用 Redis 做过异步队列吗，是如何实现的使用 list 类型保存数据信息</h4>
<p>rpush 生产消息，lpop 消费消息，当 lpop 没有消息时，可以 sleep 一段时间，然后再检查有没有信息，如果不想 sleep 的话，可以使用 blpop, 在没有信息的时候，会一直阻塞，直到信息的到来。</p>
<p>redis 可以通过 pub/sub 主题订阅模式实现一个生产者，多个消费者，当然也存在一定的缺点，当消费者下线时，生产的消息会丢失。</p>
<h4 id="redis-主从复制如何实现的redis-的集群模式如何实现redis-的-key-是如何寻址的">redis 主从复制如何实现的？redis 的集群模式如何实现？redis 的 key 是如何寻址的？</h4>
<p>主从复制实现：
主节点将自己内存中的数据做一份快照，将快照发给从节点，从节点将数据恢复到内存中。之后再每次增加新数据的时候，主节点以类似于 mysql 的二进制日志方式将语句发送给从节点，从节点拿到主节点发送过来的语句进行重放。</p>
<p>分片方式：</p>
<pre><code>--客户端分片
--基于代理的分片
    ● Twemproxy
    ● codis
--路由查询分片
    ● Redis-cluster（本身提供了自动将数据分散到 Redis Cluster 不同节点的能力，整个数据集合的某个数据子集存储在哪个节点对于用户来说是透明的）
</code></pre>
<p>redis-cluster 分片原理：Cluster 中有一个 16384 长度的槽(虚拟槽)，编号分别为 0-16383。</p>
<p>每个 Master 节点都会负责一部分的槽，当有某个 key 被映射到某个 Master 负责的槽，那么这个 Master 负责为这个 key 提供服务，至于哪个 Master 节点负责哪个槽，可以由用户指定，也可以在初始化的时候自动生成，只有 Master 才拥有槽的所有权。Master 节点维护着一个 16384/8 字节的位序列，Master 节点用 bit 来标识对于某个槽自己是否拥有。比如对于编号为 1 的槽，Master 只要判断序列的第二位（索引从 0 开始）是不是为 1 即可。</p>
<p>这种结构很容易添加或者删除节点。比如如果我想新添加个节点 D, 我需要从节点 A、B、C 中得部分槽到 D 上。</p>
<h4 id="redis-过期策略都有哪些lru-算法知道吗写一下-java-代码实现">redis 过期策略都有哪些？LRU 算法知道吗？写一下 java 代码实现？</h4>
<p>过期策略:</p>
<pre><code>定时过期(一 key 一定时器)，
惰性过期：只有使用 key 时才判断 key 是否已过期，过期则清除。
定期过期：前两者折中。
</code></pre>
<p>LRU 算法实现：</p>
<pre><code>1.通过双向链表来实现，新数据插入到链表头部；
2.每当缓存命中（即缓存数据被访问），则将数据移到链表头部；
3.当链表满的时候，将链表尾部的数据丢弃。
</code></pre>
<p>LinkedHashMap：HashMap 和双向链表合二为一即是 LinkedHashMap。HashMap 是无序的，LinkedHashMap 通过维护一个额外的双向链表保证了迭代顺序。该迭代顺序可以是插入顺序（默认），也可以是访问顺序。</p>
<h5 id="缓存更新策略即如何让缓存和-mysql-保持一致性">缓存更新策略（即如何让缓存和 mysql 保持一致性）？</h5>
<pre><code>key 过期清除（超时剔除）策略
惰性过期（类比懒加载，这是懒过期）：只有当访问一个 key 时，才会判断该 key是否已过期，过期则清除。该策略可以最大化地节省 CPU 资源，却对内存非常不友好。极端情况可能出现大量的过期 key 没有再次被访问，从而不会被清除，占用大量内存。
定期过期：每隔一定的时间，会扫描一定数量的数据库的 expires 字典中一定数量的 key，并清除其中已过期的 key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得 CPU 和内存资源达到最优的平衡效果。(expires 字典会保存所有设置了过期时间的 key 的过期时间数据，其中，key 是指向键空间中的某个键的指针，value 是该键的毫秒精度的 UNIX 时间戳表示的过期时间。键空间是指该 Redis 集群中保存的所有键。)
</code></pre>
<p>问：比如这么个场景，我设计了很多 key，过期时间是 5 分钟，当前内存占用率是 50%。但是 5 分钟到了，内存占用率还是很高，请问为什么？</p>
<pre><code>Redis 中同时使用了惰性过期和定期过期两种过期策略，即使过期时间到了，但是有部分并没有真正删除，等待惰性删除。
</code></pre>
<h5 id="为什么有定期还要有惰性呢">为什么有定期还要有惰性呢？</h5>
<p>其实很简单，比如 10 万个 key 就要过期了，Redis默认是 100ms 检查一波。如果他检查出 10 万个即将要清除，那他接下来的时间基本都是在干这些清空内存的事了，那肯定影响性能，所以他只会部分删除，剩下的等惰性。</p>
<h3 id="集群">集群</h3>
<h4 id="是否使用过-redis-集群集群的原理是什么">是否使用过 Redis 集群，集群的原理是什么？</h4>
<p>Redis Sentinel 着眼于高可用，在 master 宕机时会自动将 slave 提升为 master，继续提供服务。</p>
<p>Redis Cluster 着眼于扩展性，在单个 redis 内存不足时，使用 Cluster 进行分片存储。</p>
<h4 id="redis-集群如何保证一致性">redis 集群如何保证一致性？</h4>
<h4 id="redis-集群的主从复制模型是怎样的">Redis 集群的主从复制模型是怎样的？</h4>
<p>为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型,每个节点都会有 N-1 个复制品.</p>
<h4 id="redis-集群会有写操作丢失吗为什么">Redis 集群会有写操作丢失吗？为什么？</h4>
<p>Redis 并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操作。</p>
<h4 id="redis-集群之间是如何复制的">Redis 集群之间是如何复制的？</h4>
<p>异步复制</p>
<h4 id="redis-集群最大节点个数是多少">Redis 集群最大节点个数是多少？</h4>
<p>16384 个</p>
<h4 id="redis-集群如何选择数据库">Redis 集群如何选择数据库？</h4>
<p>Redis 集群目前无法做数据库选择，默认在 0 数据库。</p>
<h4 id="redis-集群实现">Redis 集群实现？</h4>
<p>需要结合真实案例去分析，这里给大家推荐一个不错的博客。
<a href="https://blog.csdn.net/yfkiss/article/details/38944179" target="_blank">https://blog.csdn.net/yfkiss/article/details/38944179</a></p>
<h4 id="redis-集群采用虚拟槽方式高可用原理和哨兵模式原理类似30-版本或以上才有">redis 集群（采用虚拟槽方式，高可用）原理（和哨兵模式原理类似，3.0 版本或以上才有）？</h4>
<p>Redis 集群内节点通过 ping/pong 消息实现节点通信，消息不但可以传播节点槽信息，还可以传播其他状态如：主从状态、节点故障等。</p>
<p>因此故障发现也是通过消息传播机制实现的，主要环节包括：主观下线（pfail）和客观下线（fail）</p>
<p>主客观下线:</p>
<pre><code>1 主观下线：集群中每个节点都会定期向其他节点发送 ping 消息，接收节点回复 pong 消息作为响应。如果通信一直失败，则发送节点会把接收节点标记为主观下线（pfail）状态。
2 客观下线：超过半数，对该主节点做客观下线
3 主节点选举出某一主节点作为领导者，来进行故障转移。
4 故障转移（选举从节点作为新主节点）
</code></pre>
<h4 id="redis-集群方案应该怎么做都有哪些方案">Redis 集群方案应该怎么做？都有哪些方案？</h4>
<p>1.codis</p>
<p>2.目前用的最多的集群方案，基本和 twemproxy 一致的效果，但它支持在节点数量改变情况下，旧节点数据可恢复到新 hash 节点。redis cluster3.0 自带的集群，特点在于他的分布式算法不是一致性 hash，而是 hash 槽的概念，以及自身支持节点设置从节点。具体看官方文档介绍。</p>
<p>3.在业务代码层实现，起几个毫无关联的 redis 实例，在代码层，对 key 进行 hash 计算，然后去对应的 redis 实例操作数据。这种方式对 hash 层代码要求比较高，考虑部分包括，节点失效后的替代算法方案，数据震荡后的自动脚本恢复，实例的监控，等等。</p>
<h4 id="redis-集群方案什么情况下会导致整个集群不可用">Redis 集群方案什么情况下会导致整个集群不可用？</h4>
<p>有 A，B，C 三个节点的集群,在没有复制模型的情况下,如果节点 B 失败了，那么整个集群就会以为缺少 5501-11000 这个范围的槽而不可用。</p>
<h3 id="事务">事务</h3>
<h4 id="redis-的事务">Redis 的事务？</h4>
<p>一、Redis 事务允许一组命令在单一步骤中执行。事务有两个属性，说明如下：</p>
<pre><code>a) 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。
b) Redis 事务是原子的。原子意味着要么所有的命令都执行，要么都不执行；
</code></pre>
<p>二、一个事务从开始到执行会经历以下三个阶段：</p>
<pre><code>a) 开始事务
b) 命令入队
c) 执行事务
</code></pre>
<h4 id="怎么理解-redis-事务">怎么理解 Redis 事务？</h4>
<p>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行，事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p>
<p>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</p>
<h4 id="redis-事务相关的命令有哪几个">Redis 事务相关的命令有哪几个？</h4>
<p>MULTI、EXEC、DISCARD、WATCH</p>
<h3 id="哨兵">哨兵</h3>
<h4 id="redis-中的-sentinel-哨兵模式-的作用">redis 中的 sentinel (哨兵模式) 的作用？</h4>
<p>在哨兵模式下，如果主机宕机了，会在从机里面投票选出一个从机当主机，之后如果原来的主机又回来了，在较短的时间内还没有被哨兵模式监控到的时候，回来的主机就是自己一个人单独一套体系自己是光杆司令，但是一会儿功夫，哨兵模式监控到了这个重启的主机后，哨兵模式会告诉这个新来的主机，已经换老大了，你需要跟着新老大混，这个时候新来的就会自动变为从机依附于前面投票选出来的主机</p>
<h4 id="哨兵模式实现原理28-版本或更高才有">哨兵模式实现原理？（2.8 版本或更高才有）</h4>
<p>1.三个定时监控任务：</p>
<pre><code>1.1 每隔 10s，每个 S 节点（哨兵节点）会向主节点和从节点发送 info 命令获取最新的拓扑结构
1.2 每隔 2s，每个 S 节点会向某频道上发送该 S 节点对于主节点的判断以及当前 Sl 节点的信息，同时每个 Sentinel 节点也会订阅该频道，来了解其他 S 节点以及它们对主节点的判断（做客观下线依据）
1.3 每隔 1s，每个 S 节点会向主节点、从节点、其余 S 节点发送一条 ping 命令做一次心跳检测(心跳检测机制)，来确认这些节点当前是否可达
</code></pre>
<p>2.主客观下线：</p>
<pre><code>2.1 主观下线：根据第三个定时任务对没有有效回复的节点做主观下线处理
2.2 客观下线：若主观下线的是主节点，会咨询其他 S 节点对该主节点的判断，超过半数，对该主节点做客观下线
</code></pre>
<p>3.选举出某一哨兵节点作为领导者，来进行故障转移。
选举方式：raft算法。</p>
<p>每个 S 节点有一票同意权，哪个 S 节点做出主观下线的时候，就会询问其他 S 节点是否同意其为领导者。获得半数选票的则成为领导者。基本谁先做出客观下线，谁成为领导者。</p>
<p>4.故障转移（选举新主节点流程）：</p>
<h4 id="主从复制模式下主挂了怎么办">主从复制模式下，主挂了怎么办？</h4>
<p>redis 提供了哨兵模式（高可用）</p>
<p>何谓哨兵模式？就是通过哨兵节点进行自主监控主从节点以及其他哨兵节点，发现主节点故障时自主进行故障转移。</p>
<h3 id="订阅">订阅</h3>
<h4 id="redis-也可以进行发布订阅消息吗">redis 也可以进行发布订阅消息吗？</h4>
<p>可以，（然后可以引出哨兵模式（后面会讲）怎么互相监督的，就是因为每隔 2秒哨兵节点会发布对某节点的判断和自身的信息到某频道，每个哨兵订阅该频道获取其他哨兵节点和主从节点的信息，以达到哨兵间互相监控和对主从节点的监控）和很多专业的消息队列系统（例如 Kafka、RocketMQ）相比，Redis 的发布订阅略显粗糙，例如无法实现消息堆积和回溯。但胜在足够简单。</p>
<h3 id="持久化">持久化</h3>
<h4 id="redis-能否将数据持久化如何实现">redis 能否将数据持久化，如何实现？</h4>
<p>能，将内存中的数据异步写入硬盘中，两种方式：RDB（默认）和 AOF</p>
<p>RDB 持久化原理：</p>
<pre><code>通过 bgsave 命令触发，然后父进程执行 fork 操作创建子进程，子进程创建 RDB 文件，根据父进程内存生成临时快照文件，完成后对原有文件进行原子替换（定时一次性将所有数据进行快照生成一份副本存储在硬盘中）
优点：是一个紧凑压缩的二进制文件，Redis 加载 RDB 恢复数据远远快于 AOF的方式。
缺点：由于每次生成 RDB 开销较大，非实时持久化，
</code></pre>
<p>AOF 持久化原理：</p>
<pre><code>开启后，Redis 每执行一个修改数据的命令，都会把这个命令添加到 AOF 文件中。
优点：实时持久化。
缺点：所以 AOF 文件体积逐渐变大，需要定期执行重写操作来降低文件体积，加载慢
</code></pre>
<h4 id="redis-提供了哪几种持久化方式">Redis 提供了哪几种持久化方式？</h4>
<p>RDB 持久化方式能够在指定的时间间隔能对你的数据进行快照存储.</p>
<p>AOF 持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据,AOF 命令以 Redis 协议追加保存每次写的操作到文件末尾.</p>
<p>Redis 还能对AOF 文件进行后台重写,使得 AOF 文件的体积不至于过大. 如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式.</p>
<p>你也可以同时开启两种持久化方式, 在这种情况下, 当 Redis 重启的时候会优先载入AOF文件来恢复原始的数据,因为在通常情况下 AOF 文件保存的数据集要比RDB 文件保存的数据集要完整. 最重要的事情是了解 RDB 和 AOF 持久化方式的不同,让我们以 RDB 持久化方式开始。</p>
<h4 id="如何选择合适的持久化方式">如何选择合适的持久化方式？</h4>
<p>一般来说， 如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久化功能。如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失，那么你可以只使用 RDB 持久化。</p>
<p>有很多用户都只使用 AOF 持久化，但并不推荐这种方式：</p>
<p>因为定时生成RDB快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比AOF恢复的速度要快，除此之外， 使用 RDB 还可以避免之前提到的 AOF 程序的bug。</p>
<h4 id="修改配置不重启-redis-会实时生效吗">修改配置不重启 Redis 会实时生效吗？</h4>
<p>针对运行实例，有许多配置选项可以通过 CONFIG SET 命令进行修改，而无需执行任何形式的重启。</p>
<p>从 Redis 2.2 开始，可以从 AOF 切换到 RDB 的快照持久性或其他方式而不需要重启 Redis。检索 &ldquo;CONFIG GET *&rdquo; 命令获取更多信息。但偶尔重新启动是必须的，如为升级 Redis 程序到新的版本，或者当你需要修改某些目前CONFIG 命令还不支持的配置参数的时候。</p>
<h4 id="redis-持久化数据和缓存怎么做扩容">Redis 持久化数据和缓存怎么做扩容？</h4>
<p>如果 Redis 被当做缓存使用，使用一致性哈希实现动态扩容缩容。</p>
<h4 id="知道-redis-的持久化吗底层如何实现的有什么优点缺点">知道 redis 的持久化吗？底层如何实现的？有什么优点缺点？</h4>
<p>RDB(Redis DataBase:在不同的时间点将 redis 的数据生成的快照同步到磁盘等介质上):内存到硬盘的快照，定期更新。缺点：耗时，耗性能(fork+io 操作)，易丢失数据。</p>
<p>AOF(Append Only File：将 redis 所执行过的所有指令都记录下来，在下次 redis 重启时，只需要执行指令就可以了):写日志。缺点：体积大，恢复速度慢。</p>
<p>bgsave 做镜像全量持久化，aof 做增量持久化。因为 bgsave 会消耗比较长的时间，不够实时，在停机的时候会导致大量的数据丢失，需要 aof 来配合，在 redis 实例重启时，优先使用 aof 来恢复内存的状态，如果没有 aof 日志，就会使用 rdb 文件来恢复。Redis 会定期做</p>
<p>aof 重写，压缩 aof 文件日志大小。Redis4.0 之后有了混合持久化的功能，将 bgsave 的全量和 aof 的增量做了融合处理，这样既保证了恢复的效率又兼顾了数据的安全性。bgsave 的原理，fork 和 cow, fork 是指 redis 通过创建子进程来进行 bgsave 操作，cow 指的是 copy on write，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。</p>
<h3 id="缓存">缓存</h3>
<h4 id="什么是缓存穿透如何避免">什么是缓存穿透？如何避免？</h4>
<p>缓存穿透</p>
<pre><code>一般的缓存系统，都是按照 key 去缓存查询，如果不存在对应的 value，就应该去后端系统查找（比如DB）。一些恶意的请求会故意查询不存在的 key,请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。

（缓存穿透指的是查询一个根本不存在的数据，缓存层不命中，又去查存储层，又不命中。但如果有大量这种查询不存在的数据的请求过来，会对存储层有较大压力，若是恶意攻击，后果就很严重）
</code></pre>
<p>如何避免？</p>
<pre><code>1：缓存空值存在的问题：对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该 key 对应的数据 insert 了之后清理缓存。
2：布隆过滤器存在的问题：对一定不存在的 key 进行过滤。可以把所有的可能存在的 key 放到一个大的 Bitmap 中，查询时通过该 bitmap 过滤。
</code></pre>
<h4 id="什么是缓存雪崩何如避免">什么是缓存雪崩？何如避免？</h4>
<pre><code>当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，会给后端系统带来很大压力。导致系统崩溃。
</code></pre>
<p>如何避免？</p>
<pre><code>1：在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个 key 只允许一个线程查询数据和写缓存，其他线程等待。
2：做二级缓存，A1 为原始缓存，A2 为拷贝缓存，A1 失效时，可以访问 A2，A1 缓存失效时间设置为短期，A2 设置为长期
3：不同的 key，设置不同的过期时间，让缓存失效的时间点尽量均匀
</code></pre>
<h4 id="缓存穿透缓存击穿缓存雪崩解决方案">缓存穿透、缓存击穿、缓存雪崩解决方案？</h4>
<p>缓存穿透：指查询一个一定不存在的数据，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到 DB 去查询，可能导致 DB 挂掉。</p>
<p>解决方案：</p>
<pre><code>1.查询返回的数据为空，仍把这个空结果进行缓存，但过期时间会比较短；
2.布隆过滤器：将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对 DB 的查询。
</code></pre>
<p>缓存击穿：对于设置了过期时间的 key，缓存在某个时间点过期的时候，恰好这时间点对这个 Key 有大量的并发请求过来，这些请求发现缓存过期一般都会从后端 DB 加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把 DB 压垮。</p>
<p>解决方案：</p>
<pre><code>1.使用互斥锁：当缓存失效时，不立即去 load db，先使用如 Redis 的 setnx 去设置一个互斥锁，当操作成功返回时再进行 load db 的操作并回设缓存，否则重试 get 缓存的方法。
2.永远不过期：物理不过期，但逻辑过期（后台异步线程去刷新）。
</code></pre>
<p>缓存雪崩：设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到 DB，DB 瞬时压力过重雪崩。与缓存击穿的区别：雪崩是很多 key，击穿是某一个key 缓存。</p>
<p>解决方案：</p>
<pre><code>将缓存失效时间分散开，比如可以在原有的失效时间基础上增加一个随机值，比如 1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。
</code></pre>
<h4 id="缓存粒度控制">缓存粒度控制？</h4>
<h3 id="锁">锁</h3>
<h4 id="redis分布式锁实现原理学习httpsbbshuaweicloudcomblogs238821pdfimagesredis分布式锁实现原理学习pdf"><a href="https://bbs.huaweicloud.com/blogs/238821" target="_blank">redis分布式锁实现原理学习</a>|<a href="./images/redis%e5%88%86%e5%b8%83%e5%bc%8f%e9%94%81%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86%e5%ad%a6%e4%b9%a0.pdf">PDF</a></h4>
<h4 id="使用过-redis-分布式锁么它是怎么实现的">使用过 Redis 分布式锁么，它是怎么实现的？</h4>
<p>先拿 setnx 来争抢锁，抢到之后，再用 expire 给锁加一个过期时间防止锁忘记了释放。</p>
<h5 id="如果在-setnx-之后执行-expire-之前进程意外-crash-或者要重启维护了那会怎么样">如果在 setnx 之后执行 expire 之前进程意外 crash 或者要重启维护了，那会怎么样？</h5>
<p>set 指令有非常复杂的参数，这个应该是可以同时把 setnx 和 expire 合成一条指令来用的！</p>
<h4 id="使用过-redis-做异步队列么你是怎么用的有什么缺点">使用过 Redis 做异步队列么，你是怎么用的？有什么缺点？</h4>
<p>一般使用 list 结构作为队列，rpush 生产消息，lpop 消费消息。当 lpop 没有消息的时候，要适当 sleep 一会再重试。</p>
<p>缺点：</p>
<pre><code>在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如 rabbitmq 等。
</code></pre>
<h5 id="能不能生产一次消费多次呢">能不能生产一次消费多次呢？</h5>
<p>使用 pub/sub 主题订阅者模式，可以实现 1:N 的消息队列。</p>
<h4 id="使用-redis-如何设计分布式锁说一下实现思路使用-zk-可以吗如何实现这两种有什么区别">使用 redis 如何设计分布式锁？说一下实现思路？使用 zk 可以吗？如何实现？这两种有什么区别？</h4>
<p>redis:</p>
<pre><code>1.线程 A setnx(上锁的对象,超时时的时间戳 t1)，如果返回 true，获得锁。
2.线程 B 用 get 获取 t1,与当前时间戳比较,判断是是否超时,没超时 false,若超时执行第 3 步;
3.计算新的超时时间 t2,使用 getset 命令返回 t3(该值可能其他线程已经修改过),如果t1==t3，获得锁，如果 t1!=t3 说明锁被其他线程获取了。
4.获取锁后，处理完业务逻辑，再去判断锁是否超时，如果没超时删除锁，如果已超时，
</code></pre>
<p>不用处理（防止删除其他线程的锁）。</p>
<p>zk:</p>
<pre><code>1.客户端对某个方法加锁时，在 zk 上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点 node1;
2.客户端获取该路径下所有已经创建的子节点，如果发现自己创建的 node1 的序号是最小的，就认为这个客户端获得了锁。
3.如果发现 node1 不是最小的，则监听比自己创建节点序号小的最大的节点，进入等待。
4.获取锁后，处理完逻辑，删除自己创建的 node1 即可。
</code></pre>
<p>区别:zk 性能差一些，开销大，实现简单。</p>
<h3 id="优化">优化</h3>
<h4 id="无底洞优化">无底洞优化？</h4>
<p>造成原因：redis 分布式越来越多，导致性能反而下降，因为键值分布到更多的节点上，所以无论是 Memcache 还是 Redis 的分布式，批量操作通常需要从不同节点上获取，相比于单机批量操作只涉及一次网络操作，分布式批量操作 会涉及多次网络时间。 即分布式过犹不及。</p>
<h4 id="雪崩优化">雪崩优化</h4>
<p>如果缓存层由于某些原因不能提供服务，于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会级联宕机的情况。</p>
<h4 id="热点-key-优化">热点 key 优化</h4>
<p>当前 key 是一个热点 key（例如一个热门的娱乐新闻），并发量非常大。</p>
<h4 id="redis-如何做内存优化">Redis 如何做内存优化？</h4>
<p>尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。</p>
<p>比如你的 web 系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的 key,而是应该把这个用户的所有信息存储到一张散列表里面。</p>
<h4 id="都有哪些办法可以降低-redis-的内存使用情况呢">都有哪些办法可以降低 Redis 的内存使用情况呢？</h4>
<p>如果你使用的是 32 位的 Redis 实例，可以好好利用 Hash,list,sorted set,set 等集合类型数据，因为通常情况下很多小的 Key-Value 可以用更紧凑的方式存放到一起。</p>
<h4 id="redis-常见性能问题和解决方案">Redis 常见性能问题和解决方案？</h4>
<pre><code>(1) Master 最好不要做任何持久化工作，如 RDB 内存快照和 AOF 日志文件
(2) 如果数据比较重要，某个 Slave 开启 AOF 备份数据，策略设置为每秒同步一次
(3) 为了主从复制的速度和连接的稳定性，Master 和 Slave 最好在同一个局域网内
(4) 尽量避免在压力很大的主库上增加从库
(5) 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master &lt;- Slave1 &lt;- Slave2&lt;- Slave3... 这样的结构方便解决单点故障问题，实现 Slave 对 Master 的替换。如果Master 挂了，可以立刻启用 Slave1 做 Master，其他不变。
</code></pre>
<h4 id="redis-常见的性能问题都有哪些如何解决">Redis 常见的性能问题都有哪些？如何解决？</h4>
<pre><code>1. Master 写内存快照，save 命令调度 rdbSave 函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以 Master最好不要写内存快照。

2. Master AOF 持久化，如果不重写 AOF 文件，这个持久化方式对性能的影响是最小的，但是 AOF 文件会不断增大，AOF 文件过大会影响 Master重启的恢复速度。Master 最好不要做任何持久化工作，包括内存快照和AOF 日志文件，特别是不要启用内存快照做持久化,如果数据比较关键，某个 Slave 开启 AOF 备份数据，策略为每秒同步一次。

3. Master 调用 BGREWRITEAOF 重写 AOF 文件，AOF 在重写的时候会占大量的 CPU 和内存资源，导致服务 load 过高，出现短暂服务暂停现象。

4. Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，Slave和 Master 最好在同一个局域网内
</code></pre>
<h4 id="怎样解决数据库高并发的问题">怎样解决数据库高并发的问题？</h4>
<p><code>解决数据库高并发的常见方案</code>：</p>
<pre><code>1） 缓存式的 Web 应用程序架构：
    在 Web 层和 DB (数据库) 层之间加一层 cache 层，主要目的：减少数据库读取负担，提高数据读取速度。cache 存取的媒介是内存，可以考虑采用分布式的 cache 层，这样更容易破除内存容量的限制，同时增加了灵活性。
2） 增加 Redis 缓存数据库
3） 增加数据库索引
4） 页面静态化：
    效率最高、消耗最小的就是纯静态化的 html 页面，所以我们尽可能使我们的网站上的页面采用静态页面来实现，这个最简单的方法其实也是最有效的方法。
用户可以直接获取页面，不用像 MVC 结构走那么多流程，比较适用于页面信息大量被前台程序调用，但是更新频率很小的情况。
5） 使用存储过程：
    处理一次请求需要多次访问数据库的操作，可以把操作整合到储存过程，这样只要一次数据库访问就可以了。
6） MySQL 主从读写分离：
    当数据库的写压力增加，cache 层（如 Memcached）只能缓解数据库的读取压力。读写集中在一个数据库上让数据库不堪重负。使用主从复制技术（master-slave 模式）来达到读写分离，以提高读写性能和读库的可扩展性。读写分离就是只在主服务器上写，只在从服务器上读，基本原理是让主数据库处理事务性查询，而从数据库处理 select 查询，数据库复制被用于把事务性查询（增删改） 导致的改变更新同步到集群中的从数据库。

MySQL 读写分离提升系统性能：
    1、主从只负责各自的读和写，极大程度缓解 X 锁和 S 锁争用。
    2、slave 可以配置 MyISAM 引擎，提升查询性能以及节约系统开销。
    3、master 直接写是并发的，slave 通过主库发送来的 binlog 恢复数据是异步的。
    4、slave 可以单独设置一些参数来提升其读的性能。
    5、增加冗余，提高可用性。

实现主从分离可以使用 MySQL 中间件如：Atlas

7） 分表分库：
    在 cache 层的高速缓存，MySQL 的主从复制，读写分离的基础上，这时 MySQL 主库的写压力开始出现瓶颈，而数据量的持续猛增，由于 MyISAM 使用表锁，在高并发下会出现严重的锁问题，大量的高并发 MySQL 应用开始使用 InnoDB 引擎代替 MyISAM。

    采用 Master-Slave 复制模式的 MySQL 架构，只能对数据库的读进行扩展，而对数据的写操作还是集中在 Master 上。这时需要对数据库的吞吐能力进一步地扩展，以满足高并发访问与海量数据存储的需求。

    对于访问极为频繁且数据量巨大的单表来说，首先要做的是减少单表的记录条数，以便减少数据查询所需的时间，提高数据库的吞吐，这就是所谓的分表【水平拆分】。

    在分表之前，首先需要选择适当的分表策略（尽量避免分出来的多表关联查询），使得数据能够较为均衡地分布到多张表中，并且不影响正常的查询。

    分表能够解决单表数据量过大带来的查询效率下降的问题，但是却无法给数据库的并发处理能力带来质的提升。

    面对高并发的读写访问，当数据库 master 服务器无法承载写操作压力时，不管如何扩展 Slave 服务器都是没有意义的，对数据库进行拆分，从而提高数据库写入能力，即分库【垂直拆分】。

8） 负载均衡集群：
    将大量的并发请求分担到多个处理节点。

    由于单个处理节点的故障不影响整个服务，负载均衡集群同时也实现了高可用性。

    负载均衡将是大型网站解决高负荷访问和大量并发请求采用的终极解决办法。
</code></pre>
<h4 id="redis-的并发竞争问题怎么解决">Redis 的并发竞争问题怎么解决？</h4>
<blockquote>
<p><code>方案一</code>：可以使用独占锁的方式，类似操作系统的 mutex 机制，不过实现相对复杂，成本较高。</p>
</blockquote>
<blockquote>
<p><code>方案二</code>：使用乐观锁的方式进行解决（成本较低，非阻塞，性能较高）</p>
</blockquote>
<h5 id="如何用乐观锁方式进行解决">如何用乐观锁方式进行解决？</h5>
<p>本质上是假设不会进行冲突，使用 redis 的命令 watch 进行构造条件</p>
<h3 id="回收">回收</h3>
<h4 id="redis-回收进程如何工作的">Redis 回收进程如何工作的？</h4>
<p>一个客户端运行了新的命令，添加了新的数据。</p>
<p>Redi 检查内存使用情况，如果大于 maxmemory 的限制, 则根据设定好的策略进行回收。</p>
<p>一个新的命令被执行，等等。</p>
<p>所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。</p>
<p>如果一个命令的结果导致大量内存被使用（例如很大的集合的交集保存到一个新的键），不用多久内存限
制就会被这个内存使用量超越。</p>
<h4 id="redis-回收使用的是什么算法">Redis 回收使用的是什么算法？</h4>
<p>LRU 算法</p>
<h3 id="mysql-对比">mysql 对比</h3>
<h4 id="redis-相比-memcached-有哪些优势">redis 相比 memcached 有哪些优势？</h4>
<pre><code>(1) memcached 所有的值均是简单的字符串，redis 作为其替代者，支持更为丰富的数据类型
(2) redis 的速度比 memcached 快很多
(3) redis 可以持久化其数据
</code></pre>
<h4 id="redis-和-memcached-什么区别">redis 和 memcached 什么区别？</h4>
<pre><code>1.mc 可缓存图片和视频。rd 支持除 k/v 更多的数据结构;
2.rd 可以使用虚拟内存，rd 可持久化和 aof 灾难恢复，rd 通过主从支持数据备份;
3.rd 可以做消息队列。
</code></pre>
<h4 id="为什么高并发下有时单线程的-redis-比多线程的memcached-效率要高">为什么高并发下有时单线程的 redis 比多线程的memcached 效率要高？</h4>
<p>原因：mc 多线程模型引入了缓存一致性和锁，加锁带来了性能损耗。</p>
<h4 id="memcache-与-redis-的区别都有哪些">Memcache 与 Redis 的区别都有哪些？</h4>
<pre><code>1)、存储方式
    Memecache 把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。Redis 有部份存在硬盘上，这样能保证数据的持久性。
2)、数据支持类型
    Memcache 对数据类型支持相对简单。Redis 有复杂的数据类型。
3)、使用底层模型不同
它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。Redis 直接自己构建了 VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。
4），value 大小
    redis 最大可以达到 1GB，而 memcache 只有 1MB
</code></pre>
<h4 id="redis-与-memcached-相比有哪些优势">Redis 与 memcached 相比有哪些优势？</h4>
<pre><code>1.memcached 所有的值均是简单的字符串，redis 作为其替代者，支持更为丰富的数据类型
2.redis 的速度比 memcached 快很多 redis 的速度比 memcached 快很多
3.redis 可以持久化其数据 redis 可以持久化其数据
</code></pre>
<h4 id="mysql-和-redis-高可用性体现在哪些方面">MySQL 和 Redis 高可用性体现在哪些方面？</h4>
<pre><code>&gt; a) MySQL Replication 是 MySQL 官方提供的主从同步方案，用于将一个 MySQL 实例的数据，同步到另一个实例中。Replication 为保证数据安全做了重要的保证，也是现在运用最广的 MySQL 容灾方案。Replication 用两个或以上的实例搭建了 MySQL 主从复制集群， 提供单点写入，多点读取的服务，实现了读的 scale out。

&gt; b) Sentinel 是 Redis 官方为集群提供的高可用解决方案。在实际项目中可以使用 sentinel 去做 Redis 自动故障转移，减少人工介入的工作量。另外 sentinel 也给客户端提供了监控消息的通知，这样客户端就可根据消息类型去判断服务器的状态，去做对应的适配操作。

&gt; c) 下面是 Sentinel 主要功能列表：
# Monitoring
Sentinel 持续检查集群中的 master、slave 状态，判断是否存活。

# Notification
在发现某个 Redis 实例死的情况下，Sentinel 能通过 API 通知系统管理员或其他程序脚本。

# Automatic failover
如果一个 master 挂掉后，sentinel 立马启动故障转移，把某个 slave 提升为 master。其他的 slave 重新配置指向新 master。

# Configuration provider
对于客户端来说 sentinel 通知是有效可信赖的。客户端会连接 sentinel 去请求当前 master 的地址，一旦发生故障 sentinel 会提供新地址给客户端。
</code></pre>
<h4 id="mysql-里有-2000w-数据redis-中只存-20w-的数据如何保证-redis-中的数据都是热点数据">MySQL 里有 2000w 数据，redis 中只存 20w 的数据，如何保证 redis 中的数据都是热点数据</h4>
<p>相关知识：redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。</p>
<p>redis 提供 6 种数据淘汰策略：</p>
<pre><code>voltile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰
allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰
no-enviction（驱逐）：禁止驱逐数据
</code></pre>
<h4 id="在选择缓存时什么时候选择-redis什么时候选择-memcached">在选择缓存时，什么时候选择 redis，什么时候选择 memcached</h4>
<p>选择 redis 的情况：</p>
<pre><code>1、复杂数据结构，value 的数据是哈希，列表，集合，有序集合等这种情况下，会选择redis, 因为 memcache 无法满足这些数据结构，最典型的的使用场景是，用户订单列表，用户消息，帖子评论等。

2、需要进行数据的持久化功能，但是注意，不要把 redis 当成数据库使用，如果 redis挂了，内存能够快速恢复热数据，不会将压力瞬间压在数据库上，没有 cache 预热的过程。对于只读和数据一致性要求不高的场景可以采用持久化存储

3、高可用，redis 支持集群，可以实现主动复制，读写分离，而对于 memcache 如果想要实现高可用，需要进行二次开发。

4、存储的内容比较大，memcache 存储的 value 最大为 1M。
</code></pre>
<p>选择 memcache 的场景：</p>
<pre><code>1、纯 KV,数据量非常大的业务，使用 memcache 更合适，原因是，
    a)memcache 的内存分配采用的是预分配内存池的管理方式，能够省去内存分配的时间，redis 是临时申请空间，可能导致碎片化。
    b)虚拟内存使用，memcache 将所有的数据存储在物理内存里，redis 有自己的 vm 机制，理论上能够存储比物理内存更多的数据，当数据超量时，引发 swap,把冷数据刷新到磁盘上，从这点上，数据量大时，memcache 更快
    c)网络模型，memcache 使用非阻塞的 IO 复用模型，redis 也是使用非阻塞的 IO 复用模型，但是 redis 还提供了一些非 KV 存储之外的排序，聚合功能，复杂的 CPU 计算，会阻塞整个 IO 调度，从这点上由于 redis 提供的功能较多，memcache 更快些
    d) 线程模型，memcache 使用多线程，主线程监听，worker 子线程接受请求，执行读写，这个过程可能存在锁冲突。redis 使用的单线程，虽然无锁冲突，但是难以利用多核的特性提升吞吐量。
</code></pre>
<h3 id="mongo-对比">Mongo 对比</h3>
<h4 id="redis-和-mongodb-的优缺点">Redis 和 MongoDB 的优缺点</h4>
<p>MongoDB 和 Redis 都是 NoSQL，采用结构型数据存储。</p>
<p>二者在使用场景中，存在一定的区别，这也主要由于二者在内存映射的处理过程，持久化的处理方法不同。
MongoDB 建议集群部署，更多的考虑到集群方案，Redis 更偏重于进程顺序写入，虽然支持集群，也仅限于主 - 从模式。</p>
<p>Redis 优点：</p>
<pre><code>1) 读写性能优异
2) 支持数据持久化，支持 AOF 和 RDB 两种持久化方式
3) 支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。
4) 数据结构丰富：数据结构丰富：支持 string、hash、set、sortedset、list 等数据结构。
</code></pre>
<p>缺点：</p>
<pre><code>1) Redis 不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的 IP 才能恢复。
2) 主机宕机，宕机前有部分数据未能及时同步到从机，切换 IP 后还会引入数据不一致的问题，降低了系统的可用性。
3) Redis 的主从复制采用全量复制，复制过程中主机会 fork 出一个子进程对内存做一份快照，并将子进程的内存快照保存为文件发送给从机，这一过程需要确保主机有足够多的空余内存。若快照文件较大，对集群的服务能力会产生较大的影响，而且复制过程是在从机新加入集群或者从机和主机网络断开重连时都会进行，也就是网络波动都会造成主机和从机间的一次全量的数据复制，这对实际的系统运营造成了不小的麻烦。
4) Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题， 运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。
</code></pre>
<p>MongoDB 优点:</p>
<pre><code>1）弱一致性（最终一致），更能保证用户的访问速度
2）文档结构的存储方式，能够更便捷的获取数
3）内置 GridFS，高效存储二进制大对象 (比如照片和视频)
4）支持复制集、主备、互为主备、自动分片等特性
5） 动态查询
6）全索引支持，扩展到内部对象和内嵌数组
</code></pre>
<p>缺点：</p>
<pre><code>1）不支持事务
2）MongoDB 占用空间过大
3）维护工具不够成熟
</code></pre>

    </div>
</article>


<div class="license markdown-body">
    <blockquote>
        <p>Unless otherwise noted, the content of this site is licensed under <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"
               target="_blank">CC BY-NC-SA 4.0</a>.</p>
    </blockquote>
</div>



            </div>
            <aside class="col-12 col-md-3 float-left sidebar">
    
    <div class="sidebar-item sidebar-pages">
        <h3>Pages</h3>
        <ul>
            
            <li>
                <a href="/">Home</a>
            </li>
            
            <li>
                <a href="/archives/">Archives</a>
            </li>
            
            <li>
                <a href="/about/">About</a>
            </li>
            
            <li>
                <a href="/search/">Search</a>
            </li>
            
        </ul>
    </div>
    
    <div class="sidebar-item sidebar-links">
        <h3>Links</h3>
        <ul>
            
            <li>
                <a href="https://github.com/dsrkafuu" target="_blank"><span>GitHub</span></a>
            </li>
            
        </ul>
    </div>
    
    <div class="sidebar-item sidebar-tags">
        <h3>Tags</h3>
        <div>
            
            <span>
                <a href="/tags/aria2/">Aria2</a>
            </span>
            
            <span>
                <a href="/tags/chrome/">Chrome</a>
            </span>
            
            <span>
                <a href="/tags/companyquestionset/">CompanyQuestionSet</a>
            </span>
            
            <span>
                <a href="/tags/database/">DataBase</a>
            </span>
            
            <span>
                <a href="/tags/datestructure_algorithm/">DateStructure_Algorithm</a>
            </span>
            
            <span>
                <a href="/tags/docker/">Docker</a>
            </span>
            
            <span>
                <a href="/tags/editor/">Editor</a>
            </span>
            
            <span>
                <a href="/tags/flask/">Flask</a>
            </span>
            
            <span>
                <a href="/tags/frontend/">FrontEnd</a>
            </span>
            
            <span>
                <a href="/tags/git/">Git</a>
            </span>
            
            <span>
                <a href="/tags/images/">images</a>
            </span>
            
            <span>
                <a href="/tags/input_method/">Input_Method</a>
            </span>
            
            <span>
                <a href="/tags/interviewquestions/">InterviewQuestions</a>
            </span>
            
            <span>
                <a href="/tags/linux/">Linux</a>
            </span>
            
            <span>
                <a href="/tags/mongodb/">MongoDB</a>
            </span>
            
            <span>
                <a href="/tags/mysql/">MySQL</a>
            </span>
            
            <span>
                <a href="/tags/neovim/">NeoVim</a>
            </span>
            
            <span>
                <a href="/tags/other/">Other</a>
            </span>
            
            <span>
                <a href="/tags/others/">Others</a>
            </span>
            
            <span>
                <a href="/tags/phone/">Phone</a>
            </span>
            
            <span>
                <a href="/tags/proxy/">Proxy</a>
            </span>
            
            <span>
                <a href="/tags/python/">Python</a>
            </span>
            
            <span>
                <a href="/tags/redis/">Redis</a>
            </span>
            
            <span>
                <a href="/tags/sublime/">Sublime</a>
            </span>
            
            <span>
                <a href="/tags/thought/">Thought</a>
            </span>
            
            <span>
                <a href="/tags/tools/">Tools</a>
            </span>
            
            <span>
                <a href="/tags/vim/">Vim</a>
            </span>
            
            <span>
                <a href="/tags/windows/">Windows</a>
            </span>
            
        </div>
    </div>
    <div class="sidebar-item sidebar-toc">
        <h3>Table of Contents</h3><nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li></li>
        <li><a href="#分区">分区</a></li>
        <li><a href="#同步">同步</a></li>
        <li><a href="#集群">集群</a></li>
        <li><a href="#事务">事务</a></li>
        <li><a href="#哨兵">哨兵</a></li>
        <li><a href="#订阅">订阅</a></li>
        <li><a href="#持久化">持久化</a></li>
        <li><a href="#缓存">缓存</a></li>
        <li><a href="#锁">锁</a></li>
        <li><a href="#优化">优化</a></li>
        <li><a href="#回收">回收</a></li>
        <li><a href="#mysql-对比">mysql 对比</a></li>
        <li><a href="#mongo-对比">Mongo 对比</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
</aside>

        </div>
        <div class="btn">
    <div class="btn-menu" id="btn-menu">
        <i class="iconfont icon-grid-sharp"></i>
    </div>
    <div class="btn-toggle-mode">
        <i class="iconfont icon-contrast-sharp"></i>
    </div>
    <div class="btn-scroll-top">
        <i class="iconfont icon-chevron-up-circle-sharp"></i>
    </div>
</div>
<aside class="sidebar-mobile" style="display: none;">
  <div class="sidebar-wrapper">
    
    <div class="sidebar-item sidebar-pages">
        <h3>Pages</h3>
        <ul>
            
            <li>
                <a href="/">Home</a>
            </li>
            
            <li>
                <a href="/archives/">Archives</a>
            </li>
            
            <li>
                <a href="/about/">About</a>
            </li>
            
            <li>
                <a href="/search/">Search</a>
            </li>
            
        </ul>
    </div>
    
    <div class="sidebar-item sidebar-links">
        <h3>Links</h3>
        <ul>
            
            <li>
                <a href="https://github.com/dsrkafuu" target="_blank"><span>GitHub</span></a>
            </li>
            
        </ul>
    </div>
    
    <div class="sidebar-item sidebar-tags">
        <h3>Tags</h3>
        <div>
            
            <span>
                <a href="/tags/aria2/">Aria2</a>
            </span>
            
            <span>
                <a href="/tags/chrome/">Chrome</a>
            </span>
            
            <span>
                <a href="/tags/companyquestionset/">CompanyQuestionSet</a>
            </span>
            
            <span>
                <a href="/tags/database/">DataBase</a>
            </span>
            
            <span>
                <a href="/tags/datestructure_algorithm/">DateStructure_Algorithm</a>
            </span>
            
            <span>
                <a href="/tags/docker/">Docker</a>
            </span>
            
            <span>
                <a href="/tags/editor/">Editor</a>
            </span>
            
            <span>
                <a href="/tags/flask/">Flask</a>
            </span>
            
            <span>
                <a href="/tags/frontend/">FrontEnd</a>
            </span>
            
            <span>
                <a href="/tags/git/">Git</a>
            </span>
            
            <span>
                <a href="/tags/images/">images</a>
            </span>
            
            <span>
                <a href="/tags/input_method/">Input_Method</a>
            </span>
            
            <span>
                <a href="/tags/interviewquestions/">InterviewQuestions</a>
            </span>
            
            <span>
                <a href="/tags/linux/">Linux</a>
            </span>
            
            <span>
                <a href="/tags/mongodb/">MongoDB</a>
            </span>
            
            <span>
                <a href="/tags/mysql/">MySQL</a>
            </span>
            
            <span>
                <a href="/tags/neovim/">NeoVim</a>
            </span>
            
            <span>
                <a href="/tags/other/">Other</a>
            </span>
            
            <span>
                <a href="/tags/others/">Others</a>
            </span>
            
            <span>
                <a href="/tags/phone/">Phone</a>
            </span>
            
            <span>
                <a href="/tags/proxy/">Proxy</a>
            </span>
            
            <span>
                <a href="/tags/python/">Python</a>
            </span>
            
            <span>
                <a href="/tags/redis/">Redis</a>
            </span>
            
            <span>
                <a href="/tags/sublime/">Sublime</a>
            </span>
            
            <span>
                <a href="/tags/thought/">Thought</a>
            </span>
            
            <span>
                <a href="/tags/tools/">Tools</a>
            </span>
            
            <span>
                <a href="/tags/vim/">Vim</a>
            </span>
            
            <span>
                <a href="/tags/windows/">Windows</a>
            </span>
            
        </div>
    </div>
    
    
    
    <div class="sidebar-item sidebar-toc">
        <h3>Table of Contents</h3>
        <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li></li>
        <li><a href="#分区">分区</a></li>
        <li><a href="#同步">同步</a></li>
        <li><a href="#集群">集群</a></li>
        <li><a href="#事务">事务</a></li>
        <li><a href="#哨兵">哨兵</a></li>
        <li><a href="#订阅">订阅</a></li>
        <li><a href="#持久化">持久化</a></li>
        <li><a href="#缓存">缓存</a></li>
        <li><a href="#锁">锁</a></li>
        <li><a href="#优化">优化</a></li>
        <li><a href="#回收">回收</a></li>
        <li><a href="#mysql-对比">mysql 对比</a></li>
        <li><a href="#mongo-对比">Mongo 对比</a></li>
      </ul>
    </li>
  </ul>
</nav>
    </div>
    
    
  </div>
</aside>
    </main>

    <footer>
    <div class="container-lg clearfix">
        <div class="col-12 footer">
            
            <span>&copy; 2020-2023
                <a href="/">会讲笑话的咸鱼王</a>
                
                | Powered by <a href="https://github.com/dsrkafuu/hugo-theme-fuji/"
                   target="_blank">Fuji-v2</a> &amp; <a href="https://gohugo.io/"
                                                    target="_blank">Hugo</a> 
            </span>
        </div>
    </div>
</footer>

    
<script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js" integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js" integrity="sha512-q583ppKrCRc7N5O0n2nzUiJ+suUv7Et1JGels4bXOaMFQcamPk9HjdUknZuuFjBNs7tsMuadge5k9RzdmO+1GQ==" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/prismjs@1.27.0/components/prism-core.min.js" integrity="sha512-LCKPTo0gtJ74zCNMbWw04ltmujpzSR4oW+fgN+Y1YclhM5ZrHCZQAJE4quEodcI/G122sRhSGU2BsSRUZ2Gu3w==" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/prismjs@1.27.0/plugins/autoloader/prism-autoloader.min.js" integrity="sha512-GP4x8UWxWyh4BMbyJGOGneiTbkrWEF5izsVJByzVLodP8CuJH/n936+yQDMJJrOPUHLgyPbLiGw2rXmdvGdXHA==" crossorigin="anonymous"></script>



<script defer src="/assets/js/fuji.min.63d5cea7f1ee8e64c26d4e8c531866bbd7ff11fe457b0d3a4ac05238db02912b502392ba5e887d50456e8d0c755f47d50d5a0202aa58235aa683b276d053bf3c.js" integrity="sha512-Y9XOp/HujmTCbU6MUxhmu9f/Ef5Few06SsBSONsCkStQI5K6Xoh9UEVujQx1X0fVDVoCAqpYI1qmg7J20FO/PA=="></script>



</body>

</html>
